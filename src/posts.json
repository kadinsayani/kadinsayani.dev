[{"title":"Building a Shell in Rust","id":"building-a-shell-in-rust","description":"Building a customizable Unix-like shell in Rust.","author":"Kadin Sayani","pubDate":"2023-12-14T00:00:00.000Z","content":"\nAs I continue my quest across the vast Rust landscape, pursuing the knowledge of a rockstar systems developer, I ponder the thought of writing my own Unix shell. In this blog post, I'll walk you through the steps involved with writing a shell program in Rust! We'll cover the basics of a shell, as well as add support for customizing the prompt by editing a TOML config file.\n\n## What is a shell?\n\nA Unix Shell is a program that provides a CLI for Unix-like operating systems. User's can enter text commands which execute programs and display their output. \n\n## How does a shell work?\n\n1. Command Input\n- Users interact with a shell by entering commands into a terminal.\n2. Command Parsing\n- The shell parses the command entered by the user.\n3. Command Execution and Process Creation\n- The shell locates the executable file associated with the command, and creates a new process to execute the command. The new process is a child of the shell process.\n\nOf course, modern shells include more features such as shell scripting, I/O redirection (redirecting input/output or pipes), job control, etc. For the purpose of this blog, we'll just focus on executing commands and setting up a custom prompt.\n\n## Prerequisites\n\nIf you'd like to follow along with this blog post, you'll need to have Rust installed. It would also help to have a basic understanding of Unix-like environments and programming.\n\n## Creating a Rust Application\n\nRun the following commands in your terminal:\n\n```zsh\ncargo new rustsh\ncd rustsh\n```\n\n## Adding Project Dependencies\n\nFor our project, we will need to add the following dependencies:\n\n```toml\n[dependencies]\nshell-words = \"1.1.0\"\natty = \"0.2\"\ncolored = \"2.0.4\"\nwhoami = \"1.4.1\"\ntoml = \"0.7.6\"\nserde = \"1.0.188\"\nserde_derive = \"1.0.188\"\ndirs = \"2.0\"\n```\n\nAnd, we'll add the following crates to main.rs:\n\n```rust\nuse atty::Stream;\nuse colored::Colorize;\nuse shell_words;\nuse std::{env, error::Error, io, io::Write, path::Path, process::Command};\nuse whoami::username;\n```\n\n## Reading from stdin\n\nFirst, we'll create a function to read input from stdin:\n\n```rust\nfn read_input() -> io::Result<String> {\n    let mut buffer = String::new();\n    io::stdin().read_line(&mut buffer)?;\n    Ok(buffer.trim().to_string())\n}\n```\n\nIn our `main()` function, we'll set up a loop which receives input, parses the text, and will eventually execute the command.\n\n```rust\nif atty::is(Stream::Stdout) {\n    loop {\n        let prompt: String = \"$\";\n        io::stdout().flush.expect(\"Failed to flush stdout\");\n        let input = match read_input() {\n            Ok(input) => input,\n            Err(err) => {\n                eprintln!(\"{}\", err);\n                continue;\n            }\n        };\n    \n        let tokens = match shell_words::split(&input) {\n            Ok(tokens) => tokens,\n            Err(err) => {\n                eprintln!(\"{}\", err);\n                continue;\n            }\n        };\n\n        let command = &tokens[0];\n        let args = &tokens[1..];\n    }\n}\n```\n\n## Executing Commands\n\nNext, we'll add a function `execute_command()`:\n\n```rust\nfn execute_system_command(command: &str, args: &[String]) -> Result<String, Box<dyn Error>> {\n    match command {\n        \"cd\" => {\n            let path = Path::new(&args[0]);\n            match env::set_current_dir(&path) {\n                Ok(()) => Ok('\\n'.to_string()),\n                Err(err) => Err(format!(\"Error: {}\", err).into()),\n            }\n        }\n        command => {\n            let output = Command::new(command)\n                .args(args)\n                .output()\n                .expect(\"Failed to execute command\");\n\n            if output.status.success() {\n                Ok(String::from_utf8_lossy(&output.stdout).to_string())\n            } else {\n                Ok(String::from_utf8_lossy(&output.stderr).to_string())\n            }\n        }\n    }\n}\n```\n\nAnd update our `main()`:\n\n```rust\n// previous code\n\nmatch execute_command(&command, &args) {\n    Ok(result) => println!(\"{}, result),\n    Err(err) => eprintln!(\"{:?}\", err),\n}\n```\n\nGreat! We now have a working shell.\n\n## Customizing the Prompt\n\n"}]