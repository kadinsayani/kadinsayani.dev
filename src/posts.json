[{"title":"Building a Shell in Rust","id":"building-a-shell-in-rust","description":"Building a Unix-like shell in Rust.","author":"Kadin Sayani","pubDate":"2023-12-14T00:00:00.000Z","content":"\nEmbarking on a journey through the expansive terrain of Rust, I find myself driven by the ambition to acquire the prowess of a seasoned systems developer. One intriguing idea that crossed my mind was to create my own Unix shell. In this blog post, I'll guide you through the process of crafting a shell program using Rust, a powerful systems programming language!\n\n## What is a shell?\n\nA Unix Shell is a program that provides a command-line interface (CLI) for Unix-like operating systems. Users can enter text commands which execute programs and display their output. The shell interprets these commands and communicates with the operating system to execute them, acting as a bridge between the user and the system. It's a powerful tool, allowing users to manipulate files, run scripts, and perform complex tasks with just a few keystrokes.\n\n## How does a shell work?\n\n1. Command Input\n- Users interact with a shell by entering commands into a terminal.\n2. Command Parsing\n- The shell parses the command entered by the user.\n3. Command Execution and Process Creation\n- The shell locates the executable file associated with the command, and creates a new process to execute the command. The new process is a child of the shell process.\n\nOf course, modern shells include more features such as shell scripting, I/O redirection (redirecting input/output or pipes), job control, etc. For the purpose of this blog, we'll just focus on executing commands.\n\n## Prerequisites\n\nIf you'd like to follow along with this blog post, you'll need to have Rust installed. It would also help to have a basic understanding of Unix-like environments and programming.\n\n## Creating a Rust Application\n\n```zsh\ncargo new rustsh\ncd rustsh\n```\n\nThe `cargo new rustsh` command creates a new Rust application in a directory named `rustsh`. The `new` command generates a \"Hello, World!\" program in a file named `main.rs` and a `Cargo.toml` file, which is the package manifest. The `main.rs` file is located in the `src` directory. This is where we'll write the code for our shell.\n\nThe `cd rustsh` command changes the current directory to the `rustsh` directory, which is where we'll be working.\n\nBy default, `cargo new` creates a binary application, which is exactly what we need for our shell. A binary application is an application that's compiled to machine code and can be directly executed by the computer's operating system. This is in contrast to a library, which is a collection of code that other programs can use.\n\nTo compile and run the application, you can use the `cargo run` command. This will compile the `main.rs` file into a binary executable and then run that executable. You should see the \"Hello, World!\" message printed to the terminal.\n\n## Adding Project Dependencies\n\nFor our project, we will need to add the following dependencies:\n\n```toml\n[dependencies]\nshell-words = \"1.1.0\"\natty = \"0.2\"\n```\n\nAnd, we'll add the following crates to main.rs:\n\n```rust\nuse atty::Stream;\nuse shell_words;\nuse std::{env, error::Error, io, io::Write, path::Path, process::Command};\n```\n\n## Reading from stdin\n\nFirst, we'll create a function to read input from stdin:\n\n```rust\nfn read_input() -> io::Result<String> {\n    let mut buffer = String::new();\n    io::stdin().read_line(&mut buffer)?;\n    Ok(buffer.trim().to_string())\n}\n```\n\nThe function begins by creating a mutable `String` buffer. The `read_line()` method from `io::stdin()` is then used to read user input into this buffer. The `read_line()` method is a blocking operation, meaning it will wait until the user has entered some input before it returns. It returns a `Result` type, which is an enum that can be either `Ok` (containing the number of bytes read) or `Err` (containing an error). \n\nThe `?` operator is used here to handle this `Result`. If `read_line()` returns `Ok`, the `?` operator unwraps the result (i.e., it extracts the number of bytes read from the `Ok` variant). If `read_line()` returns `Err`, the `?` operator returns early from the function and propagates the error. This means that if an error occurs while reading the line, the function will stop executing and return the error.\n\nIn our `main()` function, we'll set up a loop which receives input, parses the text, and will eventually execute the command.\n\n```rust\nif atty::is(Stream::Stdout) {\n    loop {\n        let prompt: String = \"$ \".to_string();\n        print!(\"{}\", prompt);\n        io::stdout().flush().expect(\"Failed to flush stdout\");\n        let input = match read_input() {\n            Ok(input) => input,\n            Err(err) => {\n                eprintln!(\"{}\", err);\n                continue;\n            }\n        };\n\n        let tokens = match shell_words::split(&input) {\n            Ok(tokens) => tokens,\n            Err(err) => {\n                eprintln!(\"{}\", err);\n                continue;\n            }\n        };\n\n        let command = &tokens[0];\n        let args = &tokens[1..];\n    }\n}\n```\n\nThe shell loop calls `read_input()` and handles the `Result` accordingly. We then tokenize the input to separate the inputted command and arguments. After tokenizing, the command and arguments are ready to be processed and executed by the shell.\n\n## Executing Commands\n\nNext, we'll add a function called `execute_command()` This function will take a reference to the command (a string slice) and an array of arguments. If you're unfamiliar with slices, I recommend taking a look at the [Rust documentation](https://doc.rust-lang.org/book/ch04-03-slices.html).\n\n```rust\nfn execute_command(command: &str, args: &[String]) -> Result<String, Box<dyn Error>> {\n    match command {\n        \"cd\" => {\n            let path = Path::new(&args[0]);\n            match env::set_current_dir(&path) {\n                Ok(()) => Ok('\\n'.to_string()),\n                Err(err) => Err(format!(\"Error: {}\", err).into()),\n            }\n        }\n        command => {\n            let output = Command::new(command)\n                .args(args)\n                .output()\n                .expect(\"Failed to execute command\");\n\n            if output.status.success() {\n                Ok(String::from_utf8_lossy(&output.stdout).to_string())\n            } else {\n                Ok(String::from_utf8_lossy(&output.stderr).to_string())\n            }\n        }\n    }\n}\n```\n\nIn this function, we use pattern matching to handle different commands. First, we add a custom implementation for the `cd` command, which changes the current working directory to the path provided as an argument. If changing the directory is successful, we return a newline character as a `String`; if it fails, we return an error message.\n\nFor all other commands, we use the `std::process::Command` crate to spawn a new process to execute the given command with the provided arguments. The `Command::new(command)` function creates a new `Command` that, when configured, can spawn a process. The `args(args)` method adds arguments to the command, and the `output()` method captures the output of the command when it finishes. The `expect(\"Failed to execute command\")` call will panic if the command fails to execute.\n\nThe function then checks whether the command was successful by calling `output.status.success()`. If the command was successful, it returns the standard output (`stdout`); if it was not, it returns the standard error (`stderr`). Both `stdout` and `stderr` are returned as `String`s.\n\nWe just have one last thing to do, and that is update our `main()` function to call `execute_command()`.\n\n```rust\n// previous code in main()\n\nmatch execute_command(&command, &args) {\n    Ok(result) => println!(\"{}\", result),\n    Err(err) => eprintln!(\"{:?}\", err)\n}\n```\n\nGreat! We now have a working shell.\n\n## Wrap Up\n\nIn this blog post, we've journeyed through the process of building a basic Unix-like shell in Rust. We've delved into key concepts such as Rust error handling, pattern matching, and managing processes. I hope this post has not only provided you with a practical understanding of these concepts, but also sparked your curiosity to explore the vast capabilities of Rust. Remember, this is just the beginning - there's a whole world of advanced features and techniques in shell programming and Rust waiting for you to discover. Happy coding!"}]